<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>P1229 mine - int main() { return 0; }</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content><meta name=keywords content><link rel=canonical href=/2015/07/21/p1229-mine/><link rel=stylesheet type=text/css href='//fonts.googleapis.com/css?family=Lato:900,400,300'><link rel=stylesheet type=text/css href=//css/combined-min.css></head><body><div class=site-wrap><header class="site-header px2 px-responsive"><div class="mt2 wrap"><div class=measure><a href=/ class=site-title>int main() { return 0; }</a><nav class="site-nav right"><a href=//about/>About</a>
<a href=//tags/>Tags</a>
<a href=https://intmainreturn0.com/cv>Resume</a>
<a href=//contact/>Contact</a></form></nav><div class=clearfix></div></div></div></header><div class="post p2 p-responsive wrap" role=main><div class=measure><div class="post-header mb2"><h1 class=py2>P1229 mine</h1><span class=post-meta>Jul 21, 2015 by htfy96</span><br></div><article class=post-content><h1 id=problem>Problem</h1><p><a href=http://acm.sjtu.edu.cn/OnlineJudge/problem/1229>http://acm.sjtu.edu.cn/OnlineJudge/problem/1229</a> Mine</p><blockquote><h2 id=description>Description</h2><p>扫雷是一个很经典的小游戏，而一行数字一行雷的题目就更经典了。当然，这道题不能这么简单就算了。</p><p>问题是这样，有一个两行n列的格子，第一行里不会有雷，第二行里不会有数字。给定第一行的某些数字，数字代表该格子正下方与左右两个斜下方共三个格子里雷数目的总和。问下一行最多有多少个雷，并给出一个让雷尽可能靠后的方案（最后一个雷尽可能靠后，如果相同，倒数第二个雷尽可能靠后，以此类推）。保证一定存在一种合法的地雷安放方案。</p><h2 id=input-format>Input Format</h2><p>第一行一个整数n，表示格子的列数</p><p>第二行为一个长度为n的字符串，由‘0’、‘1’、‘2’、‘3’以及‘<em>’组成。表示第一行的数字，‘</em>’表示该格数字未定，保证不含其他字符（行末回车符除外）</p><h2 id=output-format>Output Format</h2><p>第一行为一个整数，表示最多的地雷数目</p><p>第二行为一个长度为n的字符串，由‘0’和‘1’组成，‘0’代表安全，‘1’代表有地雷。表示所要求的安放方案</p><h2 id=sample-input>Sample Input</h2><pre><code>2
1*
</code></pre><h2 id=sample-output>Sample Output</h2><pre><code>1
01
</code></pre><h2 id=数据规模>数据规模</h2><p>10%数据 ：1&lt;=n&lt;=10 40%数据 ：1&lt;=n&lt;=100000，输入中不出现‘*’号 100%数据：1&lt;=n&lt;=100000</p></blockquote><h1 id=analysis>Analysis</h1><p>dp一遍过。。。</p><p>用f[i][pre][now]表示前i位串，倒数第二位状态是pre，本位状态是now的最多地雷数。</p><pre><code>f[i][pre][now] = 
max{ 
f[i-1][0][pre]+now    (if 0+pre+now == a[i-1] or a[i-1]=='*'),
f[i-1][1][pre]+now    (if 1+pre+now == a[i-1] or a[i-1]=='*')
}
</code></pre><p>初始</p><pre><code>f[1][0][0]=0
f[1][0][1]=1
</code></pre><p>最后检验所有满足pre+now == a[n]的f[n][pre][now]，取最大的一组。</p><p>注意，由于满足最右端最大，转移方程中应优先选择第二种情况，最后时候应优先选择01而不是10。</p><p>为了记录状态，开一个b[i][pre][now]，表示在[i][pre][now]的情况下，f取得最大值时，i-2位应该取什么，这样在最后就能反向遍历了。</p><h1 id=code>Code</h1><blockquote></blockquote></article></div></div></div><footer class=footer><div class="p2 wrap"><div class="measure mt1 center"><nav class="social-icons icons"><a class="fa fa-rss rss" href=/index.xml></a>
<a class="fa fa-twitter twitter" href=https://twitter.com/HTwood96></a></nav><small>Copyright &#169; 2017<br>Powered by <a href=http://gohugo.io/ target=_blank>Hugo</a> & <a href=https://github.com/azmelanar/hugo-theme-pixyll target=_blank>Pixyll</a></small></div></div></footer><script src=/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>