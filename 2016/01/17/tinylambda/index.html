<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>TinyLambda - int main() { return 0; }</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=author content><meta name=keywords content><link rel=canonical href=https://intmainreturn0.com/2016/01/17/tinylambda/><link rel=stylesheet type=text/css href='//fonts.googleapis.com/css?family=Lato:900,400,300'><link rel=stylesheet type=text/css href=https://intmainreturn0.com/css/combined-min.css></head><body><div class=site-wrap><header class="site-header px2 px-responsive"><div class="mt2 wrap"><div class=measure><a href=https://intmainreturn0.com class=site-title>int main() { return 0; }</a><nav class="site-nav right"><a href=https://intmainreturn0.com/about/>About</a>
<a href=https://intmainreturn0.com/tags/>Tags</a>
<a href=https://intmainreturn0.com/cv>Resume</a>
<a href=https://intmainreturn0.com/contact/>Contact</a></form></nav><div class=clearfix></div></div></div></header><div class="post p2 p-responsive wrap" role=main><div class=measure><div class="post-header mb2"><h1 class=py2>TinyLambda</h1><span class=post-meta>Jan 17, 2016 by htfy96</span><br></div><article class=post-content><p>晚上突发奇想，想用C++实现一个无比简陋的lambda：只能作为匿名函数，不带闭包，无捕获，所有中间值和结果都是int，利用C++98实现。</p><p>这类lambda实际上就是Eigen这类库中延迟计算的一个原型，写起来并不复杂，大约100行左右代码就能完成。</p><p>测试例子：</p><h1 id=分析>分析</h1><p>我们最终要实现的一个东西，我们希望它具有的特性是：</p><ul><li>具有<code>int operator() (const int, const int)</code>，能当作函数使用</li><li>能在<code>+</code>、<code>&lt;</code>运算符下和整数和自身的类运算，产生一个新的这类对象</li></ul><p>之前我们分析过：对于这类抽象，如果需要运行时多态，就应该使用继承与虚函数；如果不需要，就应该使用<a href=http://www.cnblogs.com/lizhenghn/p/3667681.html title=静态多态>静态多态</a>。</p><h2 id=动态多态>动态多态</h2><p>先尝试一下动态多态的思想：</p><p>定义接口：</p><p>对于<code>+</code>，返回一个继承自<code>lambda_interface</code>的子类：</p><p>这里需要注意的是clone，众所周知构造函数不能是虚函数，但是复制构造可以利用<code>clone()</code>来变相实现虚函数的效果。</p><p>定义两个<code>placeholder</code>，它们始终返回第1/2个参数：</p><p>对于常数，我们构造一个<code>constant</code>类把它包裹起来：</p><p>测试：</p><p>迄今为止，我们已经实现了动态多态的<code>+</code>，我们发现，这一实现存在着诸多不足：</p><ul><li><code>+</code>中的常数暂时还不能自动转换成constant类型，需要手动包裹。之后的改进手段就是重载<code>+(const lambda_interface&, const int)</code>等</li><li>较为丑陋，这其中所有信息都可以编译时获得，引入了虚函数增加了大量不必要的负担，并且中间堆上分配了不少内存，容易造成性能问题。</li></ul><h2 id=静态多态>静态多态</h2><p>静态多态不利用语法上的继承来实现<code>is_a</code>的特性描述，而是利用模板+各个类相同的接口来实现一种语法在不同类上不同的表现。</p><p>例如：</p><p>这样就实现了语义上的多态性。</p><p>实现：</p><p>这个不是接口，而是为了减少代码量而把共同部分抽出来了而已：</p><p>因为一个运算符其两个操作数的类型没有统一的接口，所以利用模板来生成基类。</p><p><code>+</code>类：</p><p><code>+</code>函数也要利用模板来生成，注意：这里把<code>int</code>替换成了<code>constant</code>类：</p><p><code>replace&lt;T>::type</code>如果<code>T</code>不是<code>int</code>，返回自身，否则返回<code>constant</code></p><p><code>constant</code>和<code>placeholder</code>:</p><p>静态多态版本完成（上面省略了<code>&lt;</code>和<code>></code>，和<code>+</code>一样处理就行了</p><h1 id=总结>总结</h1><p>以上全部代码的完整版都能在：<a href=https://github.com/htfy96/CppToys/tree/master/lambdatest>https://github.com/htfy96/CppToys/tree/master/lambdatest</a> 看到</p><p>静态多态在不需要运行时信息时，不仅降低了overhead，而且给程序编写带来了很大的简洁。在这种模式下，C++中的类型可以当作<code>duck typing</code>的方式来使用，从而给了程序员很大的自由。 不过，缺点也在于弱类型约束一旦出现bug很有可能会产生大量无用报错信息，缓解这一缺点可以使用<code>SFINAE</code>，或是进入C++11年代的<code>static_assert</code>(你都有了C++11了手写什么lambda)，或是未来C++17的<code>concept</code>。</p><p>总之，C++不强迫程序员选择什么，这就是为什么我非常喜欢这门语言。</p><h1 id=self-promotion>Self-promotion</h1><p>SJTU大二本科生，寻求暑假实习中。偏向于后端，有利用Golang+redis开发的经历。</p><p>Linkedin：<a href=http://cn.linkedin.com/in/vicluo>http://cn.linkedin.com/in/vicluo</a></p></article></div></div></div><footer class=footer><div class="p2 wrap"><div class="measure mt1 center"><nav class="social-icons icons"><a class="fa fa-rss rss" href=https://intmainreturn0.com/index.xml></a>
<a class="fa fa-twitter twitter" href=https://twitter.com/HTwood96></a></nav><small>Copyright &#169; 2017<br>Powered by <a href=http://gohugo.io/ target=_blank>Hugo</a> & <a href=https://github.com/azmelanar/hugo-theme-pixyll target=_blank>Pixyll</a></small></div></div></footer><script src=https://intmainreturn0.com/js/highlight.pack.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>